data Op_61 (a : Type) (x : a) (y : a) where
  | Refl (a : Type) (x : a) : Op_61 a x x
end

let eq_elim : (a : Type) -> (p : a -> Type) -> (x y : a) -> Op_61 a x y -> p x -> p y
  = \a p x y e px ->
    case y || e
    motive (y' : a) || (e' : Op_61 a x y') || p y'
    of
    | .x || Refl .a .x -> px
    end
end

let eq_sym : (a : Type) -> (x y : a) -> Op_61 a x y -> Op_61 a y x
  = \a x y e ->
  eq_elim a (\z -> Op_61 a z x) x y e (Refl a x)
end

let eq_trans : (a : Type) -> (x y z : a) -> Op_61 a x y -> Op_61 a y z -> Op_61 a x z
  = \a x y z p q ->
  eq_elim a (\z -> Op_61 a x z) y z q p
end

let f_equal : (a b : Type) -> (f : a -> b) -> (x y : a) -> Op_61 a x y -> Op_61 b (f x) (f y)
  = \a b f x y e ->
  eq_elim a (\y -> Op_61 b (f x) (f y)) x y e (Refl b (f x))
end


data Nat where
  | Z : Nat
  | S (n : Nat) : Nat
end

let plus : Nat -> Nat -> Nat where
  | plus Z     m = m
  | plus (S n) m = S (plus n m)
end

let times : Nat -> Nat -> Nat where
  | times Z     m = Z
  | times (S n) m = plus m (times n m)
end

let plus_S_shift : (x y : Nat) -> Op_61 Nat (plus (S x) y) (plus x (S y)) where
  | plus_S_shift Z     y = Refl Nat (S y)
  | plus_S_shift (S x) y =
      f_equal Nat Nat (\x -> S x)
      (plus (S x) y) (plus x (S y))
      (plus_S_shift x y)
end

let plus_comm : (x y : Nat) -> Op_61 Nat (plus x y) (plus y x) where
  | plus_comm Z     Z     = Refl Nat Z
  | plus_comm Z     (S y) =
      f_equal Nat Nat (\x -> S x)
      (plus Z y) (plus y Z)
      (plus_comm Z y)
  | plus_comm (S x) y     =
      eq_trans Nat (S (plus x y)) (S (plus y x)) (plus y (S x))
      (f_equal Nat Nat (\x -> S x) (plus x y) (plus y x) (plus_comm x y))
      (plus_S_shift y x)
end

